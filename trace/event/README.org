
## Profile

`profile` is an example written in C .
It attaches to perf events, sampling on every processor periodically. It
shows addresses, symbols, file names, and line numbers of stacktraces.

```shell
$ sudo ./target/release/profile
COMM: swapper/6 (pid=0) @ CPU 6
Kernel:
  0 [<ffffffff81bdf010>] intel_idle+0x96
  1 [<ffffffff819959b0>] cpuidle_enter_state+0x80 /ro/source/drivers/cpuidle/cpuidle.c:238
  2 [<ffffffff81995cc9>] cpuidle_enter+0x29 /ro/source/drivers/cpuidle/cpuidle.c:353
  3 [<ffffffff810f8c0b>] do_idle+0x1bb /ro/source/kernel/sched/idle.c:243
  4 [<ffffffff810f8de9>] cpu_startup_entry+0x19 /ro/source/kernel/sched/idle.c:396
  5 [<ffffffff81044f46>] start_secondary+0x116 /ro/source/arch/x86/kernel/smpboot.c:272
  6 [<ffffffff810000f5>] secondary_startup_64_no_verify+0xb0 /ro/source/arch/x86/kernel/head_64.S:283
No Userspace Stack
```

* Table of Contents                                                     :TOC:
- [[#setup-notes][Setup notes]]
- [[#what-you-will-learn-in-this-lesson][What you will learn in this lesson]]
  - [[#the-data-and-data_end-pointers][The data and data_end pointers]]
  - [[#packet-bounds-checking][Packet bounds checking]]
  - [[#header-cursor-to-keep-track-of-current-parsing-position][Header cursor to keep track of current parsing position]]
  - [[#program-return-codes][Program return codes]]
  - [[#packet-header-definitions-and-byte-order][Packet header definitions and byte order]]
  - [[#function-inlining-and-loop-unrolling][Function inlining and loop unrolling]]
- [[#assignments][Assignments]]
  - [[#assignment-1-fix-the-bounds-checking-error][Assignment 1: Fix the bounds checking error]]
  - [[#assignment-2-parsing-the-ip-header][Assignment 2: Parsing the IP header]]
  - [[#assignment-3-parsing-the-icmpv6-header-and-reacting-to-it][Assignment 3: Parsing the ICMPv6 header and reacting to it]]
  - [[#assignment-4-adding-vlan-support][Assignment 4: Adding VLAN support]]
  - [[#assignment-5-adding-ipv4-support][Assignment 5: Adding IPv4 support]]


* What you will learn in this lesson

This lesson will teach you how to parse packet data from XDP. This is done via
direct memory access using pointers to the packet data, which is one of the
reasons for the high performance attainable using XDP. This works because the
kernel verifier will check that all data accesses are within the packet
boundaries. We will see how this works, and how you can deal with verifier
errors.

You will also learn how to decide the packet verdict via program return code
based on the packet data, and we will cover how to structure the packet parsing
code to ensure readability and code reuse.

A few points to be aware of while completing the assignments are listed below.

** The data and data_end pointers
When an XDP program is executed, it will receive as a parameter a pointer to
a =struct xdp_md= object, which contains context information about the
packet. This object is defined in =bpf.h= as follows:

#+begin_src C
struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	/* Below access go through struct xdp_rxq_info */
	__u32 ingress_ifindex; /* rxq->dev->ifindex */
	__u32 rx_queue_index;  /* rxq->queue_index  */
};
#+end_src

The last two items in this struct are just data fields which contain the
ifindex and RX queue index that the packet was received on. The program can
use this in its decision making (along with the packet data itself).

The three first items are actually pointers, even though they are defined
with the =__u32= type. The =data= field points to the start of the packet,
the =data_end= field points to the end, and the =data_meta= field points to
the metadata area that XDP programs can use to store extra metadata to
accompany the packet. In this lesson we will only be working with the =data=
and =data_end= fields.

The verifier will rewrite the pointer accesses when the program is loaded to
point to the actual packet data. But to satisfy the compiler type checking
we need to cast the fields to pointers when accessing them. For this reason,
XDP programs often start with an assignment like this:

#+begin_src C
	void *data_end = (void *)(long)ctx->data_end;
	void *data = (void *)(long)ctx->data;
#+end_src

** Packet bounds checking

As mentioned above, packet data is accessed using direct memory reads, which
the verifier will ensure are safe. However, doing this at runtime for every
pointer access would result in a significant performance overhead. So
instead, what the verifier does is check that the XDP program does its own
bounds checking; this is the purpose of the =data_end= pointer.

When the verifier performs its static analysis at load time, it will track
all memory address offsets used by the program, and look for comparisons
with the =data_end= pointer, which will be set to the end of the packet at
runtime. This means that if the program does something like this:

#+begin_src C
if (data + 10 < data_end)
  /* do something with the first 10 bytes of data */
else
  /* skip the packet access */
#+end_src

The verifier can know that all instructions in the =true= branch of the =if=
statement can safely access the first 10 bytes of the packet, while the
=else= branch cannot. So if a program does attempt to access the packet data
in the else branch, the program will be rejected.

** Header cursor to keep track of current parsing position

When going through a packet and parsing subsequent headers, it is generally
necessary to keep track of the current parsing position. When using helper
functions to parse packet headers, those helper functions generally need to
modify the current parser position. To avoid having to deal with pointer
arithmetic on pointers to pointers, we encapsulate this in a /cursor/
object, which we can pass to helper functions. The cursor is simply defined
as a single-entry struct:

#+begin_src C
/* Header cursor to keep track of current parsing position */
struct hdr_cursor {
	void *pos;
};
#+end_src

** Program return codes

The final verdict for what happens to a packet after it has been processed
by the XDP program is communicated to the kernel by means of the program
return code. These are also defined in =bpf.h=:

#+begin_src C
enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP,
	XDP_PASS,
	XDP_TX,
	XDP_REDIRECT,
};
#+end_src

=ABORTED= and =DROP= will both drop the packet, but =ABORTED= will also
trigger a tracepoint event (=xdp:xdp_exception=; this has zero overhead when
the tracepoint is not reached). =PASS= will allow the packet to continue up to the
kernel networking stack for processing, =TX= will retransmit the packet out
of the same interface it was received on, and =REDIRECT= will transmit the
packet out of another interface (where the destination interface needs to be
set by a BPF helper call prior to returning =REDIRECT=).

Note that the XDP program can perform arbitrary alterations to the packets
before these verdicts are rendered. For the =TX= and =REDIRECT= actions,
some packet data transformation is generally required (such as rewriting
ethernet header addresses), while for the others it is optional. We will see
how this can be used in the next lesson.

** Packet header definitions and byte order

Since an XDP program only receives a pointer to a raw data buffer, it will
need to do its own parsing of packet headers. To aid in this, the kernel
headers define structs that contain the packet header fields. Parsing
packets generally involves a lot of casting of data buffers to the right
struct types, as we will see in the assignments below. The header
definitions we will be using in this lesson are the following:

| Struct            | Header file          |
|-------------------+----------------------|
| =struct ethhdr=   | =<linux/if_ether.h>= |
| =struct ipv6hdr=  | =<linux/ipv6.h>=     |
| =struct iphdr=    | =<linux/ip.h>=       |
| =struct icmp6hdr= | =<linux/icmpv6.h>=   |
| =struct icmphdr=  | =<linux/icmp.h>=     |

Since the packet data comes straight off the wire, the data fields will be
in network byte order. Use the =bpf_ntohs()= and =bpf_htons()= functions to
convert to and from host byte order, respectively. See the comment at the
top of [[file:../headers/bpf_endian.h]] for why the =bpf_=-prefixed versions are
needed.

